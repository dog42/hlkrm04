The system is: Linux - 3.13.0-45-generic - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/gcc 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/2.8.11.2/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/g++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/2.8.11.2/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2380937692/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2380937692.dir/build.make CMakeFiles/cmTryCompileExec2380937692.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2380937692.dir/testCCompiler.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2380937692.dir/testCCompiler.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec2380937692
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2380937692.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2380937692.dir/testCCompiler.c.o  -o cmTryCompileExec2380937692 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3481397101/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3481397101.dir/build.make CMakeFiles/cmTryCompileExec3481397101.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec3481397101
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3481397101.dir/link.txt --verbose=1
/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3481397101 -rdynamic  
Using built-in specs.
COLLECT_GCC=/usr/bin/gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3481397101' '-rdynamic' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec3481397101 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec3481397101/fast"]
  ignore line: [make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec3481397101.dir/build.make CMakeFiles/cmTryCompileExec3481397101.dir/build]
  ignore line: [make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec3481397101]
  ignore line: [/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3481397101.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3481397101 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/gcc]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3481397101' '-rdynamic' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec3481397101 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2] ==> ignore
    arg [--sysroot=/] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec3481397101] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..]
    arg [CMakeFiles/cmTryCompileExec3481397101.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.8]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> [/usr/lib]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.8;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2278734224/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2278734224.dir/build.make CMakeFiles/cmTryCompileExec2278734224.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2278734224.dir/testCXXCompiler.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2278734224.dir/testCXXCompiler.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec2278734224
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2278734224.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2278734224.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec2278734224 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2102804897/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2102804897.dir/build.make CMakeFiles/cmTryCompileExec2102804897.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec2102804897
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2102804897.dir/link.txt --verbose=1
/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2102804897 -rdynamic  
Using built-in specs.
COLLECT_GCC=/usr/bin/g++
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2102804897' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec2102804897 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec2102804897/fast"]
  ignore line: [make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec2102804897.dir/build.make CMakeFiles/cmTryCompileExec2102804897.dir/build]
  ignore line: [make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec2102804897]
  ignore line: [/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2102804897.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2102804897 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/g++]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2102804897' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec2102804897 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2] ==> ignore
    arg [--sysroot=/] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec2102804897] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..]
    arg [CMakeFiles/cmTryCompileExec2102804897.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.8]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> [/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.8;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []


Determining if the include file iostream exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2704535313/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2704535313.dir/build.make CMakeFiles/cmTryCompileExec2704535313.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2704535313.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2704535313.dir/CheckIncludeFile.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec2704535313
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2704535313.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec2704535313.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec2704535313 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec733782914/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec733782914.dir/build.make CMakeFiles/cmTryCompileExec733782914.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec733782914.dir/TestForSTDNamespace.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec733782914.dir/TestForSTDNamespace.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec733782914
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec733782914.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec733782914.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec733782914 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2295002156/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2295002156.dir/build.make CMakeFiles/cmTryCompileExec2295002156.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2295002156.dir/TestForAnsiForScope.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2295002156.dir/TestForAnsiForScope.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec2295002156
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2295002156.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec2295002156.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec2295002156 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3678125375/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3678125375.dir/build.make CMakeFiles/cmTryCompileExec3678125375.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3678125375.dir/TestForSSTREAM.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec3678125375.dir/TestForSSTREAM.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec3678125375
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3678125375.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec3678125375.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec3678125375 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec263298650/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec263298650.dir/build.make CMakeFiles/cmTryCompileExec263298650.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec263298650.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec263298650.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec263298650
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec263298650.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec263298650.dir/CheckSymbolExists.c.o  -o cmTryCompileExec263298650 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3180608715/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3180608715.dir/build.make CMakeFiles/cmTryCompileExec3180608715.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3180608715.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec3180608715.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3180608715
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3180608715.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3180608715.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3180608715 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec971978061/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec971978061.dir/build.make CMakeFiles/cmTryCompileExec971978061.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec971978061.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_CXX_HAS_CSTDIO=1 -DTEST_KWSYS_LFS_WORKS  -o CMakeFiles/cmTryCompileExec971978061.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec971978061
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec971978061.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec971978061.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec971978061 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3546919661/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3546919661.dir/build.make CMakeFiles/cmTryCompileExec3546919661.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3546919661.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec3546919661.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3546919661
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3546919661.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3546919661.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3546919661 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec365788663/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec365788663.dir/build.make CMakeFiles/cmTryCompileExec365788663.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec365788663.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec365788663.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec365788663
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec365788663.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec365788663.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec365788663 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec233361210/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec233361210.dir/build.make CMakeFiles/cmTryCompileExec233361210.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec233361210.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec233361210.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec233361210
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec233361210.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec233361210.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec233361210 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2782807422/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2782807422.dir/build.make CMakeFiles/cmTryCompileExec2782807422.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2782807422.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec2782807422.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2782807422
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2782807422.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2782807422.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2782807422 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3250982875/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3250982875.dir/build.make CMakeFiles/cmTryCompileExec3250982875.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3250982875.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec3250982875.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3250982875
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3250982875.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3250982875.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3250982875 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2193113128/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2193113128.dir/build.make CMakeFiles/cmTryCompileExec2193113128.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2193113128.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR  -o CMakeFiles/cmTryCompileExec2193113128.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2193113128
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2193113128.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2193113128.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2193113128 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2683510173/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2683510173.dir/build.make CMakeFiles/cmTryCompileExec2683510173.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2683510173.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS  -o CMakeFiles/cmTryCompileExec2683510173.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2683510173
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2683510173.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2683510173.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2683510173 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2433805484/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2433805484.dir/build.make CMakeFiles/cmTryCompileExec2433805484.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2433805484.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE  -o CMakeFiles/cmTryCompileExec2433805484.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2433805484
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2433805484.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2433805484.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2433805484 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2572669111/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2572669111.dir/build.make CMakeFiles/cmTryCompileExec2572669111.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2572669111.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND  -o CMakeFiles/cmTryCompileExec2572669111.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2572669111
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2572669111.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2572669111.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2572669111 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3603809353/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3603809353.dir/build.make CMakeFiles/cmTryCompileExec3603809353.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3603809353.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS  -o CMakeFiles/cmTryCompileExec3603809353.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3603809353
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3603809353.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3603809353.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3603809353 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2548094784/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2548094784.dir/build.make CMakeFiles/cmTryCompileExec2548094784.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2548094784.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAVE_BINARY  -o CMakeFiles/cmTryCompileExec2548094784.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2548094784
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2548094784.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2548094784.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2548094784 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3769199847/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3769199847.dir/build.make CMakeFiles/cmTryCompileExec3769199847.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3769199847.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec3769199847.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3769199847
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3769199847.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3769199847.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3769199847 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3001458214/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3001458214.dir/build.make CMakeFiles/cmTryCompileExec3001458214.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3001458214.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec3001458214.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3001458214
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3001458214.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3001458214.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3001458214 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2475460151/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2475460151.dir/build.make CMakeFiles/cmTryCompileExec2475460151.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2475460151.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec2475460151.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2475460151
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2475460151.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2475460151.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2475460151 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3572244077/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3572244077.dir/build.make CMakeFiles/cmTryCompileExec3572244077.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3572244077.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec3572244077.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3572244077
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3572244077.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3572244077.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3572244077 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1675888078/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1675888078.dir/build.make CMakeFiles/cmTryCompileExec1675888078.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1675888078.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec1675888078.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1675888078
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1675888078.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1675888078.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1675888078 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec997085376/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec997085376.dir/build.make CMakeFiles/cmTryCompileExec997085376.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec997085376.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec997085376.dir/kwsysPlatformTestsC.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec997085376
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec997085376.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec997085376.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec997085376 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1760082860/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1760082860.dir/build.make CMakeFiles/cmTryCompileExec1760082860.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1760082860.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1760082860.dir/CheckIncludeFile.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1760082860
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1760082860.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1760082860.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1760082860 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3640145365/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3640145365.dir/build.make CMakeFiles/cmTryCompileExec3640145365.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3640145365.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3640145365.dir/CheckIncludeFile.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3640145365
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3640145365.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3640145365.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3640145365 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3851396840/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3851396840.dir/build.make CMakeFiles/cmTryCompileExec3851396840.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3851396840.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3851396840.dir/CheckIncludeFile.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3851396840
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3851396840.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3851396840.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3851396840 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec532849167/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec532849167.dir/build.make CMakeFiles/cmTryCompileExec532849167.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec532849167.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec532849167.dir/KWSYS_SIZEOF_CHAR.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec532849167
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec532849167.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec532849167.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec532849167 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2464680821/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2464680821.dir/build.make CMakeFiles/cmTryCompileExec2464680821.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2464680821.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec2464680821.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2464680821
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2464680821.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2464680821.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2464680821 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec203828425/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec203828425.dir/build.make CMakeFiles/cmTryCompileExec203828425.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec203828425.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec203828425.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec203828425
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec203828425.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec203828425.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec203828425 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2266494933/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2266494933.dir/build.make CMakeFiles/cmTryCompileExec2266494933.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2266494933.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec2266494933.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2266494933
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2266494933.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2266494933.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2266494933 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2503599595/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2503599595.dir/build.make CMakeFiles/cmTryCompileExec2503599595.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2503599595.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec2503599595.dir/kwsysPlatformTestsC.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec2503599595
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2503599595.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2503599595.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec2503599595 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1908066227/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1908066227.dir/build.make CMakeFiles/cmTryCompileExec1908066227.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1908066227.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec1908066227.dir/kwsysPlatformTestsC.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec1908066227
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1908066227.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1908066227.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec1908066227 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1657831732/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1657831732.dir/build.make CMakeFiles/cmTryCompileExec1657831732.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1657831732.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_SETENV  -o CMakeFiles/cmTryCompileExec1657831732.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1657831732
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1657831732.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1657831732.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1657831732 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3170972462/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3170972462.dir/build.make CMakeFiles/cmTryCompileExec3170972462.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3170972462.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UNSETENV  -o CMakeFiles/cmTryCompileExec3170972462.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3170972462
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3170972462.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3170972462.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3170972462 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ifaddrs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4094619498/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4094619498.dir/build.make CMakeFiles/cmTryCompileExec4094619498.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4094619498.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4094619498.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4094619498
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4094619498.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec4094619498.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4094619498 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has rlimit64 compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2184922339/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2184922339.dir/build.make CMakeFiles/cmTryCompileExec2184922339.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2184922339.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_HAS_LFS=1 -DTEST_KWSYS_CXX_HAS_RLIMIT64  -o CMakeFiles/cmTryCompileExec2184922339.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2184922339
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2184922339.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2184922339.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2184922339 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has atol compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2514207842/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2514207842.dir/build.make CMakeFiles/cmTryCompileExec2514207842.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2514207842.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ATOL  -o CMakeFiles/cmTryCompileExec2514207842.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2514207842
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2514207842.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2514207842.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2514207842 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has atoll compiled with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec21399303/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec21399303.dir/build.make CMakeFiles/cmTryCompileExec21399303.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec21399303.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ATOLL  -o CMakeFiles/cmTryCompileExec21399303.dir/kwsysPlatformTestsCXX.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec21399303
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec21399303.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec21399303.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec21399303 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3972937867/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3972937867.dir/build.make CMakeFiles/cmTryCompileExec3972937867.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3972937867.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec3972937867.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3972937867
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3972937867.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec3972937867.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3972937867 -rdynamic -lc 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3106158438/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3106158438.dir/build.make CMakeFiles/cmTryCompileExec3106158438.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3106158438.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec3106158438.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3106158438
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3106158438.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec3106158438.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3106158438 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec379793574/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec379793574.dir/build.make CMakeFiles/cmTryCompileExec379793574.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec379793574.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec379793574.dir/CheckIncludeFile.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec379793574
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec379793574.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec379793574.dir/CheckIncludeFile.c.o  -o cmTryCompileExec379793574 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3849524112/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3849524112.dir/build.make CMakeFiles/cmTryCompileExec3849524112.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3849524112.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3849524112.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3849524112
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3849524112.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3849524112.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3849524112 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2961270511/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2961270511.dir/build.make CMakeFiles/cmTryCompileExec2961270511.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2961270511.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2961270511.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2961270511
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2961270511.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2961270511.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2961270511 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3464505494/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3464505494.dir/build.make CMakeFiles/cmTryCompileExec3464505494.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3464505494.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3464505494.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3464505494
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3464505494.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3464505494.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3464505494 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2078227298/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2078227298.dir/build.make CMakeFiles/cmTryCompileExec2078227298.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2078227298.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2078227298.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2078227298
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2078227298.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2078227298.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2078227298 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3078550500/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3078550500.dir/build.make CMakeFiles/cmTryCompileExec3078550500.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3078550500.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3078550500.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3078550500
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3078550500.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3078550500.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3078550500 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3620918037/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3620918037.dir/build.make CMakeFiles/cmTryCompileExec3620918037.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3620918037.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3620918037.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3620918037
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3620918037.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3620918037.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3620918037 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2229043850/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2229043850.dir/build.make CMakeFiles/cmTryCompileExec2229043850.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2229043850.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2229043850.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2229043850
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2229043850.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2229043850.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2229043850 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1303770776/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1303770776.dir/build.make CMakeFiles/cmTryCompileExec1303770776.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1303770776.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1303770776.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1303770776
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1303770776.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1303770776.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1303770776 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2811710481/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2811710481.dir/build.make CMakeFiles/cmTryCompileExec2811710481.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2811710481.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2811710481.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2811710481
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2811710481.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2811710481.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2811710481 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4207252414/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4207252414.dir/build.make CMakeFiles/cmTryCompileExec4207252414.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4207252414.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4207252414.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4207252414
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4207252414.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4207252414.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4207252414 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec610501861/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec610501861.dir/build.make CMakeFiles/cmTryCompileExec610501861.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec610501861.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec610501861.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec610501861
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec610501861.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec610501861.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec610501861 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2923438927/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2923438927.dir/build.make CMakeFiles/cmTryCompileExec2923438927.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2923438927.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2923438927.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2923438927
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2923438927.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2923438927.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2923438927 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3297263651/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3297263651.dir/build.make CMakeFiles/cmTryCompileExec3297263651.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3297263651.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3297263651.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3297263651
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3297263651.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3297263651.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3297263651 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3606213607/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3606213607.dir/build.make CMakeFiles/cmTryCompileExec3606213607.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3606213607.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3606213607.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3606213607
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3606213607.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3606213607.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3606213607 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1793956272/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1793956272.dir/build.make CMakeFiles/cmTryCompileExec1793956272.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1793956272.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1793956272.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1793956272
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1793956272.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1793956272.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1793956272 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1463894290/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1463894290.dir/build.make CMakeFiles/cmTryCompileExec1463894290.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1463894290.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1463894290.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1463894290
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1463894290.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1463894290.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1463894290 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1414826820/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1414826820.dir/build.make CMakeFiles/cmTryCompileExec1414826820.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1414826820.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1414826820.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1414826820
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1414826820.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1414826820.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1414826820 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2310742938/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2310742938.dir/build.make CMakeFiles/cmTryCompileExec2310742938.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2310742938.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2310742938.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2310742938
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2310742938.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2310742938.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2310742938 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2816646038/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2816646038.dir/build.make CMakeFiles/cmTryCompileExec2816646038.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2816646038.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2816646038.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2816646038
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2816646038.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2816646038.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2816646038 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec84612040/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec84612040.dir/build.make CMakeFiles/cmTryCompileExec84612040.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec84612040.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec84612040.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec84612040
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec84612040.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec84612040.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec84612040 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1250092595/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1250092595.dir/build.make CMakeFiles/cmTryCompileExec1250092595.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1250092595.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1250092595.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1250092595
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1250092595.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1250092595.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1250092595 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1252709567/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1252709567.dir/build.make CMakeFiles/cmTryCompileExec1252709567.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1252709567.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1252709567.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1252709567
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1252709567.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1252709567.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1252709567 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3164277776/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3164277776.dir/build.make CMakeFiles/cmTryCompileExec3164277776.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3164277776.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3164277776.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3164277776
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3164277776.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3164277776.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3164277776 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1538928822/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1538928822.dir/build.make CMakeFiles/cmTryCompileExec1538928822.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1538928822.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1538928822.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1538928822
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1538928822.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1538928822.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1538928822 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1285921805/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1285921805.dir/build.make CMakeFiles/cmTryCompileExec1285921805.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1285921805.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1285921805.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1285921805
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1285921805.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1285921805.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1285921805 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2475175049/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2475175049.dir/build.make CMakeFiles/cmTryCompileExec2475175049.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2475175049.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2475175049.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2475175049
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2475175049.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2475175049.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2475175049 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2753875896/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2753875896.dir/build.make CMakeFiles/cmTryCompileExec2753875896.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2753875896.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2753875896.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2753875896
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2753875896.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2753875896.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2753875896 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1973779310/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1973779310.dir/build.make CMakeFiles/cmTryCompileExec1973779310.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1973779310.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1973779310.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1973779310
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1973779310.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1973779310.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1973779310 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec807249590/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec807249590.dir/build.make CMakeFiles/cmTryCompileExec807249590.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec807249590.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec807249590.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec807249590
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec807249590.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec807249590.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec807249590 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3600243516/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3600243516.dir/build.make CMakeFiles/cmTryCompileExec3600243516.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3600243516.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3600243516.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3600243516
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3600243516.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3600243516.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3600243516 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3436244646/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3436244646.dir/build.make CMakeFiles/cmTryCompileExec3436244646.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3436244646.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3436244646.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3436244646
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3436244646.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3436244646.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3436244646 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1293013596/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1293013596.dir/build.make CMakeFiles/cmTryCompileExec1293013596.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1293013596.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1293013596.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1293013596
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1293013596.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1293013596.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1293013596 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3540539295/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3540539295.dir/build.make CMakeFiles/cmTryCompileExec3540539295.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3540539295.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3540539295.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3540539295
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3540539295.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3540539295.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3540539295 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3515695337/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3515695337.dir/build.make CMakeFiles/cmTryCompileExec3515695337.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3515695337.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3515695337.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3515695337
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3515695337.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3515695337.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3515695337 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec792057744/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec792057744.dir/build.make CMakeFiles/cmTryCompileExec792057744.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec792057744.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec792057744.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec792057744
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec792057744.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec792057744.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec792057744 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1506918358/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1506918358.dir/build.make CMakeFiles/cmTryCompileExec1506918358.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1506918358.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1506918358.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1506918358
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1506918358.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1506918358.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1506918358 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3394925528/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3394925528.dir/build.make CMakeFiles/cmTryCompileExec3394925528.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3394925528.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3394925528.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3394925528
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3394925528.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3394925528.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3394925528 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1239259394/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1239259394.dir/build.make CMakeFiles/cmTryCompileExec1239259394.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1239259394.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1239259394.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1239259394
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1239259394.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1239259394.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1239259394 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1994172732/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1994172732.dir/build.make CMakeFiles/cmTryCompileExec1994172732.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1994172732.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1994172732.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1994172732
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1994172732.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1994172732.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1994172732 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1611193801/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1611193801.dir/build.make CMakeFiles/cmTryCompileExec1611193801.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1611193801.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1611193801.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1611193801
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1611193801.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1611193801.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1611193801 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec647149001/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec647149001.dir/build.make CMakeFiles/cmTryCompileExec647149001.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec647149001.dir/SIZEOF_SIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec647149001.dir/SIZEOF_SIZE_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec647149001
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec647149001.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec647149001.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec647149001 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1742325611/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1742325611.dir/build.make CMakeFiles/cmTryCompileExec1742325611.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1742325611.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1742325611.dir/SIZEOF_SSIZE_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec1742325611
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1742325611.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1742325611.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec1742325611 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1056819615/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1056819615.dir/build.make CMakeFiles/cmTryCompileExec1056819615.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1056819615.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1056819615.dir/SIZEOF_LONG_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec1056819615
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1056819615.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1056819615.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec1056819615 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1656336104/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1656336104.dir/build.make CMakeFiles/cmTryCompileExec1656336104.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1656336104.dir/SIZEOF_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1656336104.dir/SIZEOF_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec1656336104
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1656336104.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1656336104.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec1656336104 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3002871276/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3002871276.dir/build.make CMakeFiles/cmTryCompileExec3002871276.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3002871276.dir/SIZEOF_TIME_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3002871276.dir/SIZEOF_TIME_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec3002871276
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3002871276.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3002871276.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec3002871276 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2366089858/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2366089858.dir/build.make CMakeFiles/cmTryCompileExec2366089858.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2366089858.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2366089858.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2366089858
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2366089858.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2366089858.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2366089858 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1527702933/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1527702933.dir/build.make CMakeFiles/cmTryCompileExec1527702933.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1527702933.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1527702933.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1527702933
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1527702933.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1527702933.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1527702933 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1656656431/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1656656431.dir/build.make CMakeFiles/cmTryCompileExec1656656431.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1656656431.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1656656431.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1656656431
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1656656431.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1656656431.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1656656431 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3026082846/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3026082846.dir/build.make CMakeFiles/cmTryCompileExec3026082846.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3026082846.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3026082846.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3026082846
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3026082846.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3026082846.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3026082846 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1729859643/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1729859643.dir/build.make CMakeFiles/cmTryCompileExec1729859643.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1729859643.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1729859643.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1729859643
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1729859643.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1729859643.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1729859643 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec711999111/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec711999111.dir/build.make CMakeFiles/cmTryCompileExec711999111.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec711999111.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec711999111.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec711999111
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec711999111.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec711999111.dir/CheckSymbolExists.c.o  -o cmTryCompileExec711999111 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3327969066/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3327969066.dir/build.make CMakeFiles/cmTryCompileExec3327969066.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3327969066.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3327969066.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3327969066
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3327969066.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3327969066.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3327969066 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1723814964/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1723814964.dir/build.make CMakeFiles/cmTryCompileExec1723814964.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1723814964.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1723814964.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1723814964
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1723814964.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1723814964.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1723814964 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2792764014/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2792764014.dir/build.make CMakeFiles/cmTryCompileExec2792764014.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2792764014.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2792764014.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2792764014
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2792764014.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2792764014.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2792764014 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3996522194/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3996522194.dir/build.make CMakeFiles/cmTryCompileExec3996522194.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3996522194.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3996522194.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3996522194
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3996522194.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3996522194.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3996522194 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec476852430/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec476852430.dir/build.make CMakeFiles/cmTryCompileExec476852430.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec476852430.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec476852430.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec476852430
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec476852430.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec476852430.dir/CheckSymbolExists.c.o  -o cmTryCompileExec476852430 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1762258041/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1762258041.dir/build.make CMakeFiles/cmTryCompileExec1762258041.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1762258041.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1762258041.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1762258041
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1762258041.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1762258041.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1762258041 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec950651212/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec950651212.dir/build.make CMakeFiles/cmTryCompileExec950651212.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec950651212.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec950651212.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec950651212
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec950651212.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec950651212.dir/CheckSymbolExists.c.o  -o cmTryCompileExec950651212 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1981092181/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1981092181.dir/build.make CMakeFiles/cmTryCompileExec1981092181.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1981092181.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1981092181.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1981092181
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1981092181.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1981092181.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1981092181 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2974825768/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2974825768.dir/build.make CMakeFiles/cmTryCompileExec2974825768.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2974825768.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2974825768.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2974825768
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2974825768.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2974825768.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2974825768 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3587217908/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3587217908.dir/build.make CMakeFiles/cmTryCompileExec3587217908.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3587217908.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3587217908.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3587217908
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3587217908.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3587217908.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3587217908 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4117244551/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4117244551.dir/build.make CMakeFiles/cmTryCompileExec4117244551.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4117244551.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4117244551.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4117244551
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4117244551.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4117244551.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4117244551 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec900772579/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec900772579.dir/build.make CMakeFiles/cmTryCompileExec900772579.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec900772579.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec900772579.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec900772579
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec900772579.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec900772579.dir/CheckSymbolExists.c.o  -o cmTryCompileExec900772579 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1220890461/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1220890461.dir/build.make CMakeFiles/cmTryCompileExec1220890461.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1220890461.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1220890461.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1220890461
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1220890461.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1220890461.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1220890461 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec68403192/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec68403192.dir/build.make CMakeFiles/cmTryCompileExec68403192.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec68403192.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec68403192.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec68403192
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec68403192.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec68403192.dir/CheckSymbolExists.c.o  -o cmTryCompileExec68403192 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2211153872/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2211153872.dir/build.make CMakeFiles/cmTryCompileExec2211153872.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2211153872.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2211153872.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2211153872
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2211153872.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2211153872.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2211153872 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec85652402/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec85652402.dir/build.make CMakeFiles/cmTryCompileExec85652402.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec85652402.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec85652402.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec85652402
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec85652402.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec85652402.dir/CheckSymbolExists.c.o  -o cmTryCompileExec85652402 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4050937983/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4050937983.dir/build.make CMakeFiles/cmTryCompileExec4050937983.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4050937983.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4050937983.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4050937983
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4050937983.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4050937983.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4050937983 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4180178047/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4180178047.dir/build.make CMakeFiles/cmTryCompileExec4180178047.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4180178047.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4180178047.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4180178047
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4180178047.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4180178047.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4180178047 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3084922265/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3084922265.dir/build.make CMakeFiles/cmTryCompileExec3084922265.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3084922265.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3084922265.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3084922265
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3084922265.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3084922265.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3084922265 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2425351986/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2425351986.dir/build.make CMakeFiles/cmTryCompileExec2425351986.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2425351986.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2425351986.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2425351986
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2425351986.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2425351986.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2425351986 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2708126209/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2708126209.dir/build.make CMakeFiles/cmTryCompileExec2708126209.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2708126209.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2708126209.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2708126209
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2708126209.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2708126209.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2708126209 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1662585339/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1662585339.dir/build.make CMakeFiles/cmTryCompileExec1662585339.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1662585339.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1662585339.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1662585339
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1662585339.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1662585339.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1662585339 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2345907089/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2345907089.dir/build.make CMakeFiles/cmTryCompileExec2345907089.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2345907089.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2345907089.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2345907089
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2345907089.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2345907089.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2345907089 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec519776395/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec519776395.dir/build.make CMakeFiles/cmTryCompileExec519776395.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec519776395.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec519776395.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec519776395
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec519776395.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec519776395.dir/CheckSymbolExists.c.o  -o cmTryCompileExec519776395 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec805991811/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec805991811.dir/build.make CMakeFiles/cmTryCompileExec805991811.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec805991811.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec805991811.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec805991811
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec805991811.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec805991811.dir/CheckSymbolExists.c.o  -o cmTryCompileExec805991811 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec263027540/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec263027540.dir/build.make CMakeFiles/cmTryCompileExec263027540.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec263027540.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec263027540.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec263027540
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec263027540.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec263027540.dir/CheckSymbolExists.c.o  -o cmTryCompileExec263027540 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1403305099/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1403305099.dir/build.make CMakeFiles/cmTryCompileExec1403305099.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1403305099.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1403305099.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1403305099
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1403305099.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1403305099.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1403305099 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1432854852/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1432854852.dir/build.make CMakeFiles/cmTryCompileExec1432854852.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1432854852.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1432854852.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1432854852
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1432854852.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1432854852.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1432854852 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1419119487/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1419119487.dir/build.make CMakeFiles/cmTryCompileExec1419119487.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1419119487.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1419119487.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1419119487
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1419119487.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1419119487.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1419119487 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1550220174/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1550220174.dir/build.make CMakeFiles/cmTryCompileExec1550220174.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1550220174.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1550220174.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1550220174
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1550220174.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1550220174.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1550220174 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1799220928/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1799220928.dir/build.make CMakeFiles/cmTryCompileExec1799220928.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1799220928.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1799220928.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1799220928
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1799220928.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1799220928.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1799220928 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3682893556/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3682893556.dir/build.make CMakeFiles/cmTryCompileExec3682893556.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3682893556.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3682893556.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3682893556
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3682893556.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3682893556.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3682893556 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3887043321/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3887043321.dir/build.make CMakeFiles/cmTryCompileExec3887043321.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3887043321.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3887043321.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3887043321
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3887043321.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3887043321.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3887043321 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1677151803/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1677151803.dir/build.make CMakeFiles/cmTryCompileExec1677151803.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1677151803.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1677151803.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1677151803
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1677151803.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1677151803.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1677151803 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec717616854/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec717616854.dir/build.make CMakeFiles/cmTryCompileExec717616854.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec717616854.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec717616854.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec717616854
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec717616854.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec717616854.dir/CheckSymbolExists.c.o  -o cmTryCompileExec717616854 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2195532805/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2195532805.dir/build.make CMakeFiles/cmTryCompileExec2195532805.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2195532805.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec2195532805.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2195532805
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2195532805.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec2195532805.dir/CurlTests.c.o  -o cmTryCompileExec2195532805 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2162698166/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2162698166.dir/build.make CMakeFiles/cmTryCompileExec2162698166.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2162698166.dir/CurlTests.c.o
/usr/bin/gcc   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec2162698166.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2162698166
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2162698166.dir/link.txt --verbose=1
/usr/bin/gcc      -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec2162698166.dir/CurlTests.c.o  -o cmTryCompileExec2162698166 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3749783727/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3749783727.dir/build.make CMakeFiles/cmTryCompileExec3749783727.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3749783727.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3749783727.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3749783727
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3749783727.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec3749783727.dir/CurlTests.c.o  -o cmTryCompileExec3749783727 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3477972773/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3477972773.dir/build.make CMakeFiles/cmTryCompileExec3477972773.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3477972773.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec3477972773.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3477972773
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3477972773.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec3477972773.dir/CurlTests.c.o  -o cmTryCompileExec3477972773 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4092415386/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4092415386.dir/build.make CMakeFiles/cmTryCompileExec4092415386.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4092415386.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec4092415386.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4092415386
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4092415386.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec4092415386.dir/CurlTests.c.o  -o cmTryCompileExec4092415386 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1305289976/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1305289976.dir/build.make CMakeFiles/cmTryCompileExec1305289976.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1305289976.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec1305289976.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1305289976
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1305289976.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec1305289976.dir/CurlTests.c.o  -o cmTryCompileExec1305289976 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1414514201/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1414514201.dir/build.make CMakeFiles/cmTryCompileExec1414514201.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1414514201.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec1414514201.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1414514201
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1414514201.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec1414514201.dir/CurlTests.c.o  -o cmTryCompileExec1414514201 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3844019863/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3844019863.dir/build.make CMakeFiles/cmTryCompileExec3844019863.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3844019863.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec3844019863.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3844019863
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3844019863.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec3844019863.dir/CurlTests.c.o  -o cmTryCompileExec3844019863 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1609875053/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1609875053.dir/build.make CMakeFiles/cmTryCompileExec1609875053.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1609875053.dir/CurlTests.c.o
/usr/bin/gcc   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec1609875053.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1609875053
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1609875053.dir/link.txt --verbose=1
/usr/bin/gcc      -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec1609875053.dir/CurlTests.c.o  -o cmTryCompileExec1609875053 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec533399281/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec533399281.dir/build.make CMakeFiles/cmTryCompileExec533399281.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec533399281.dir/CurlTests.c.o
/usr/bin/gcc   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec533399281.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec533399281
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec533399281.dir/link.txt --verbose=1
/usr/bin/gcc      -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec533399281.dir/CurlTests.c.o  -o cmTryCompileExec533399281 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec419048629/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec419048629.dir/build.make CMakeFiles/cmTryCompileExec419048629.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec419048629.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec419048629.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c: In function 'main':
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c:405:5: warning: incompatible implicit declaration of built-in function 'memset' [enabled by default]
     memset(&hints, 0, sizeof(hints));
     ^
Linking C executable cmTryCompileExec419048629
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec419048629.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec419048629.dir/CurlTests.c.o  -o cmTryCompileExec419048629 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3454557050/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3454557050.dir/build.make CMakeFiles/cmTryCompileExec3454557050.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3454557050.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec3454557050.dir/CurlTests.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3454557050
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3454557050.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec3454557050.dir/CurlTests.c.o  -o cmTryCompileExec3454557050 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1249249609/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1249249609.dir/build.make CMakeFiles/cmTryCompileExec1249249609.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1249249609.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/gcc   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec1249249609.dir/SIZEOF_CURL_OFF_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec1249249609
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1249249609.dir/link.txt --verbose=1
/usr/bin/gcc      -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec1249249609.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec1249249609 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2407138439/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2407138439.dir/build.make CMakeFiles/cmTryCompileExec2407138439.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2407138439.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec2407138439.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2407138439
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2407138439.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec2407138439.dir/src.c.o  -o cmTryCompileExec2407138439 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1918644406/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1918644406.dir/build.make CMakeFiles/cmTryCompileExec1918644406.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1918644406.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec1918644406.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1918644406
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1918644406.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec1918644406.dir/src.c.o  -o cmTryCompileExec1918644406 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1137522031/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1137522031.dir/build.make CMakeFiles/cmTryCompileExec1137522031.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1137522031.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec1137522031.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1137522031
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1137522031.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_send    CMakeFiles/cmTryCompileExec1137522031.dir/src.c.o  -o cmTryCompileExec1137522031 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3966179016/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3966179016.dir/build.make CMakeFiles/cmTryCompileExec3966179016.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3966179016.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec3966179016.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3966179016
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3966179016.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec3966179016.dir/src.c.o  -o cmTryCompileExec3966179016 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec771452703/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec771452703.dir/build.make CMakeFiles/cmTryCompileExec771452703.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec771452703.dir/src.c.o
/usr/bin/gcc   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec771452703.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c:12:0: warning: "__unused5" redefined [enabled by default]
 #define __unused5 1
 ^
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c:8:0: note: this is the location of the previous definition
 #define __unused5
 ^
Linking C executable cmTryCompileExec771452703
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec771452703.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec771452703.dir/src.c.o  -o cmTryCompileExec771452703 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec478914762/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec478914762.dir/build.make CMakeFiles/cmTryCompileExec478914762.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec478914762.dir/src.c.o
/usr/bin/gcc   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec478914762.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec478914762
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec478914762.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec478914762.dir/src.c.o  -o cmTryCompileExec478914762 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3256668144/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3256668144.dir/build.make CMakeFiles/cmTryCompileExec3256668144.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3256668144.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3256668144.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec3256668144
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3256668144.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3256668144.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec3256668144 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3912372038/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3912372038.dir/build.make CMakeFiles/cmTryCompileExec3912372038.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3912372038.dir/src.c.o
/usr/bin/gcc   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec3912372038.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3912372038
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3912372038.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec3912372038.dir/src.c.o  -o cmTryCompileExec3912372038 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec187010490/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec187010490.dir/build.make CMakeFiles/cmTryCompileExec187010490.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec187010490.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec187010490.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec187010490
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec187010490.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec187010490.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec187010490 -rdynamic -ldl 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec679220370/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec679220370.dir/build.make CMakeFiles/cmTryCompileExec679220370.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec679220370.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec679220370.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec679220370
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec679220370.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec679220370.dir/src.c.o  -o cmTryCompileExec679220370 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4141519597/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4141519597.dir/build.make CMakeFiles/cmTryCompileExec4141519597.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4141519597.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4141519597.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4141519597
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4141519597.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4141519597.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4141519597 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3416706100/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3416706100.dir/build.make CMakeFiles/cmTryCompileExec3416706100.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3416706100.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3416706100.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3416706100
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3416706100.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3416706100.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3416706100 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec510909964/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec510909964.dir/build.make CMakeFiles/cmTryCompileExec510909964.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec510909964.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec510909964.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec510909964
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec510909964.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec510909964.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec510909964 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec547774533/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec547774533.dir/build.make CMakeFiles/cmTryCompileExec547774533.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec547774533.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec547774533.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec547774533
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec547774533.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec547774533.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec547774533 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2004613169/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2004613169.dir/build.make CMakeFiles/cmTryCompileExec2004613169.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2004613169.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2004613169.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2004613169
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2004613169.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2004613169.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2004613169 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2301211380/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2301211380.dir/build.make CMakeFiles/cmTryCompileExec2301211380.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2301211380.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2301211380.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2301211380
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2301211380.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2301211380.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2301211380 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4127392772/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4127392772.dir/build.make CMakeFiles/cmTryCompileExec4127392772.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4127392772.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4127392772.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4127392772
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4127392772.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4127392772.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4127392772 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1683977352/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1683977352.dir/build.make CMakeFiles/cmTryCompileExec1683977352.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1683977352.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1683977352.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1683977352
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1683977352.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1683977352.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1683977352 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec628635174/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec628635174.dir/build.make CMakeFiles/cmTryCompileExec628635174.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec628635174.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec628635174.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec628635174
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec628635174.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec628635174.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec628635174 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2918961580/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2918961580.dir/build.make CMakeFiles/cmTryCompileExec2918961580.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2918961580.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2918961580.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2918961580
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2918961580.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2918961580.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2918961580 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2275994664/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2275994664.dir/build.make CMakeFiles/cmTryCompileExec2275994664.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2275994664.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2275994664.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2275994664
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2275994664.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2275994664.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2275994664 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1653319913/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1653319913.dir/build.make CMakeFiles/cmTryCompileExec1653319913.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1653319913.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1653319913.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1653319913
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1653319913.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1653319913.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1653319913 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec764763006/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec764763006.dir/build.make CMakeFiles/cmTryCompileExec764763006.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec764763006.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec764763006.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec764763006
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec764763006.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec764763006.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec764763006 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec318655502/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec318655502.dir/build.make CMakeFiles/cmTryCompileExec318655502.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec318655502.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec318655502.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec318655502
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec318655502.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec318655502.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec318655502 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec981244399/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec981244399.dir/build.make CMakeFiles/cmTryCompileExec981244399.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec981244399.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec981244399.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec981244399
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec981244399.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec981244399.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec981244399 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1613720515/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1613720515.dir/build.make CMakeFiles/cmTryCompileExec1613720515.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1613720515.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1613720515.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1613720515
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1613720515.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1613720515.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1613720515 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2169928360/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2169928360.dir/build.make CMakeFiles/cmTryCompileExec2169928360.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2169928360.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2169928360.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2169928360
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2169928360.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2169928360.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2169928360 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1815367974/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1815367974.dir/build.make CMakeFiles/cmTryCompileExec1815367974.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1815367974.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1815367974.dir/CheckIncludeFiles.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1815367974
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1815367974.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1815367974.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1815367974 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3539844635/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3539844635.dir/build.make CMakeFiles/cmTryCompileExec3539844635.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3539844635.dir/src.c.o
/usr/bin/gcc   -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec3539844635.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3539844635
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3539844635.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec3539844635.dir/src.c.o  -o cmTryCompileExec3539844635 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3717979738/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3717979738.dir/build.make CMakeFiles/cmTryCompileExec3717979738.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3717979738.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3717979738.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3717979738
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3717979738.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin    CMakeFiles/cmTryCompileExec3717979738.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3717979738 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1791468535/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1791468535.dir/build.make CMakeFiles/cmTryCompileExec1791468535.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1791468535.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec1791468535.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1791468535
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1791468535.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin    CMakeFiles/cmTryCompileExec1791468535.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1791468535 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec700909931/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec700909931.dir/build.make CMakeFiles/cmTryCompileExec700909931.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec700909931.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec700909931.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec700909931
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec700909931.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin    CMakeFiles/cmTryCompileExec700909931.dir/CheckFunctionExists.c.o  -o cmTryCompileExec700909931 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec900699095/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec900699095.dir/build.make CMakeFiles/cmTryCompileExec900699095.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec900699095.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec900699095.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec900699095
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec900699095.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin    CMakeFiles/cmTryCompileExec900699095.dir/CheckFunctionExists.c.o  -o cmTryCompileExec900699095 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1166162360/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1166162360.dir/build.make CMakeFiles/cmTryCompileExec1166162360.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1166162360.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec1166162360.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1166162360
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1166162360.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin    CMakeFiles/cmTryCompileExec1166162360.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1166162360 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3122397381/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3122397381.dir/build.make CMakeFiles/cmTryCompileExec3122397381.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3122397381.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3122397381.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3122397381
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3122397381.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin    CMakeFiles/cmTryCompileExec3122397381.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3122397381 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2725789148/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2725789148.dir/build.make CMakeFiles/cmTryCompileExec2725789148.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2725789148.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec2725789148.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2725789148
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2725789148.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin    CMakeFiles/cmTryCompileExec2725789148.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2725789148 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2136531135/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2136531135.dir/build.make CMakeFiles/cmTryCompileExec2136531135.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2136531135.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2136531135.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2136531135
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2136531135.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin    CMakeFiles/cmTryCompileExec2136531135.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2136531135 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1757337393/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1757337393.dir/build.make CMakeFiles/cmTryCompileExec1757337393.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1757337393.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1757337393.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1757337393
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1757337393.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin    CMakeFiles/cmTryCompileExec1757337393.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1757337393 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2080180632/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2080180632.dir/build.make CMakeFiles/cmTryCompileExec2080180632.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2080180632.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2080180632.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2080180632
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2080180632.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin    CMakeFiles/cmTryCompileExec2080180632.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2080180632 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1544617342/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1544617342.dir/build.make CMakeFiles/cmTryCompileExec1544617342.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1544617342.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1544617342.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1544617342
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1544617342.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin    CMakeFiles/cmTryCompileExec1544617342.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1544617342 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec715956060/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec715956060.dir/build.make CMakeFiles/cmTryCompileExec715956060.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec715956060.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec715956060.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec715956060
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec715956060.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin    CMakeFiles/cmTryCompileExec715956060.dir/CheckFunctionExists.c.o  -o cmTryCompileExec715956060 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3972717122/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3972717122.dir/build.make CMakeFiles/cmTryCompileExec3972717122.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3972717122.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec3972717122.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3972717122
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3972717122.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin    CMakeFiles/cmTryCompileExec3972717122.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3972717122 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1867670359/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1867670359.dir/build.make CMakeFiles/cmTryCompileExec1867670359.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1867670359.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec1867670359.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1867670359
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1867670359.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin    CMakeFiles/cmTryCompileExec1867670359.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1867670359 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2666176640/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2666176640.dir/build.make CMakeFiles/cmTryCompileExec2666176640.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2666176640.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2666176640.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2666176640
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2666176640.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin    CMakeFiles/cmTryCompileExec2666176640.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2666176640 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2222425078/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2222425078.dir/build.make CMakeFiles/cmTryCompileExec2222425078.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2222425078.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2222425078.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2222425078
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2222425078.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin    CMakeFiles/cmTryCompileExec2222425078.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2222425078 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2748054441/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2748054441.dir/build.make CMakeFiles/cmTryCompileExec2748054441.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2748054441.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2748054441.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2748054441
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2748054441.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2748054441.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2748054441 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2698224840/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2698224840.dir/build.make CMakeFiles/cmTryCompileExec2698224840.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2698224840.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2698224840.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2698224840
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2698224840.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2698224840.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2698224840 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4069863259/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4069863259.dir/build.make CMakeFiles/cmTryCompileExec4069863259.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4069863259.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec4069863259.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4069863259
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4069863259.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin    CMakeFiles/cmTryCompileExec4069863259.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4069863259 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2865207558/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2865207558.dir/build.make CMakeFiles/cmTryCompileExec2865207558.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2865207558.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec2865207558.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2865207558
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2865207558.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin    CMakeFiles/cmTryCompileExec2865207558.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2865207558 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3191804949/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3191804949.dir/build.make CMakeFiles/cmTryCompileExec3191804949.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3191804949.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3191804949.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3191804949
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3191804949.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin    CMakeFiles/cmTryCompileExec3191804949.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3191804949 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1559880579/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1559880579.dir/build.make CMakeFiles/cmTryCompileExec1559880579.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1559880579.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec1559880579.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1559880579
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1559880579.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin    CMakeFiles/cmTryCompileExec1559880579.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1559880579 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2080019406/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2080019406.dir/build.make CMakeFiles/cmTryCompileExec2080019406.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2080019406.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2080019406.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2080019406
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2080019406.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin    CMakeFiles/cmTryCompileExec2080019406.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2080019406 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3609632097/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3609632097.dir/build.make CMakeFiles/cmTryCompileExec3609632097.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3609632097.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec3609632097.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3609632097
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3609632097.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin    CMakeFiles/cmTryCompileExec3609632097.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3609632097 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1279371198/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1279371198.dir/build.make CMakeFiles/cmTryCompileExec1279371198.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1279371198.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec1279371198.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1279371198
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1279371198.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin    CMakeFiles/cmTryCompileExec1279371198.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1279371198 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3538958736/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3538958736.dir/build.make CMakeFiles/cmTryCompileExec3538958736.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3538958736.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3538958736.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3538958736
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3538958736.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin    CMakeFiles/cmTryCompileExec3538958736.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3538958736 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3091780991/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3091780991.dir/build.make CMakeFiles/cmTryCompileExec3091780991.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3091780991.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec3091780991.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3091780991
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3091780991.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin    CMakeFiles/cmTryCompileExec3091780991.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3091780991 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2847274083/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2847274083.dir/build.make CMakeFiles/cmTryCompileExec2847274083.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2847274083.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2847274083.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2847274083
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2847274083.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin    CMakeFiles/cmTryCompileExec2847274083.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2847274083 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3695134603/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3695134603.dir/build.make CMakeFiles/cmTryCompileExec3695134603.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3695134603.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec3695134603.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3695134603
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3695134603.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin    CMakeFiles/cmTryCompileExec3695134603.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3695134603 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1360140343/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1360140343.dir/build.make CMakeFiles/cmTryCompileExec1360140343.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1360140343.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec1360140343.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1360140343
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1360140343.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin    CMakeFiles/cmTryCompileExec1360140343.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1360140343 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec578257914/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec578257914.dir/build.make CMakeFiles/cmTryCompileExec578257914.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec578257914.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec578257914.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec578257914
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec578257914.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin    CMakeFiles/cmTryCompileExec578257914.dir/CheckFunctionExists.c.o  -o cmTryCompileExec578257914 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3168916090/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3168916090.dir/build.make CMakeFiles/cmTryCompileExec3168916090.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3168916090.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec3168916090.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3168916090
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3168916090.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin    CMakeFiles/cmTryCompileExec3168916090.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3168916090 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1960355945/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1960355945.dir/build.make CMakeFiles/cmTryCompileExec1960355945.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1960355945.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1960355945.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1960355945
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1960355945.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin    CMakeFiles/cmTryCompileExec1960355945.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1960355945 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2186157270/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2186157270.dir/build.make CMakeFiles/cmTryCompileExec2186157270.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2186157270.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2186157270.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2186157270
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2186157270.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin    CMakeFiles/cmTryCompileExec2186157270.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2186157270 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3494070880/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3494070880.dir/build.make CMakeFiles/cmTryCompileExec3494070880.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3494070880.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec3494070880.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3494070880
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3494070880.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin    CMakeFiles/cmTryCompileExec3494070880.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3494070880 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1342161746/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1342161746.dir/build.make CMakeFiles/cmTryCompileExec1342161746.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1342161746.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1342161746.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1342161746
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1342161746.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin    CMakeFiles/cmTryCompileExec1342161746.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1342161746 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1134779830/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1134779830.dir/build.make CMakeFiles/cmTryCompileExec1134779830.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1134779830.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1134779830.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1134779830
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1134779830.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin    CMakeFiles/cmTryCompileExec1134779830.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1134779830 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1314547150/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1314547150.dir/build.make CMakeFiles/cmTryCompileExec1314547150.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1314547150.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec1314547150.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1314547150
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1314547150.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin    CMakeFiles/cmTryCompileExec1314547150.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1314547150 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3247455118/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3247455118.dir/build.make CMakeFiles/cmTryCompileExec3247455118.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3247455118.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec3247455118.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3247455118
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3247455118.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin    CMakeFiles/cmTryCompileExec3247455118.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3247455118 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec186700634/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec186700634.dir/build.make CMakeFiles/cmTryCompileExec186700634.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec186700634.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec186700634.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec186700634
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec186700634.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin    CMakeFiles/cmTryCompileExec186700634.dir/CheckFunctionExists.c.o  -o cmTryCompileExec186700634 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1231944814/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1231944814.dir/build.make CMakeFiles/cmTryCompileExec1231944814.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1231944814.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec1231944814.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1231944814
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1231944814.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin    CMakeFiles/cmTryCompileExec1231944814.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1231944814 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec401396212/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec401396212.dir/build.make CMakeFiles/cmTryCompileExec401396212.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec401396212.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec401396212.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec401396212
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec401396212.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin    CMakeFiles/cmTryCompileExec401396212.dir/CheckFunctionExists.c.o  -o cmTryCompileExec401396212 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3454383658/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3454383658.dir/build.make CMakeFiles/cmTryCompileExec3454383658.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3454383658.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec3454383658.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3454383658
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3454383658.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin    CMakeFiles/cmTryCompileExec3454383658.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3454383658 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec702257357/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec702257357.dir/build.make CMakeFiles/cmTryCompileExec702257357.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec702257357.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec702257357.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec702257357
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec702257357.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin    CMakeFiles/cmTryCompileExec702257357.dir/CheckFunctionExists.c.o  -o cmTryCompileExec702257357 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec372260676/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec372260676.dir/build.make CMakeFiles/cmTryCompileExec372260676.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec372260676.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec372260676.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec372260676
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec372260676.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin    CMakeFiles/cmTryCompileExec372260676.dir/CheckFunctionExists.c.o  -o cmTryCompileExec372260676 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1492053209/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1492053209.dir/build.make CMakeFiles/cmTryCompileExec1492053209.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1492053209.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec1492053209.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1492053209
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1492053209.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin    CMakeFiles/cmTryCompileExec1492053209.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1492053209 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3867448709/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3867448709.dir/build.make CMakeFiles/cmTryCompileExec3867448709.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3867448709.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec3867448709.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3867448709
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3867448709.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin    CMakeFiles/cmTryCompileExec3867448709.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3867448709 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2501279186/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2501279186.dir/build.make CMakeFiles/cmTryCompileExec2501279186.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2501279186.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2501279186.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2501279186
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2501279186.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin    CMakeFiles/cmTryCompileExec2501279186.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2501279186 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1871100516/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1871100516.dir/build.make CMakeFiles/cmTryCompileExec1871100516.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1871100516.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec1871100516.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1871100516
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1871100516.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin    CMakeFiles/cmTryCompileExec1871100516.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1871100516 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1807770355/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1807770355.dir/build.make CMakeFiles/cmTryCompileExec1807770355.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1807770355.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec1807770355.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1807770355
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1807770355.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin    CMakeFiles/cmTryCompileExec1807770355.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1807770355 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2369790767/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2369790767.dir/build.make CMakeFiles/cmTryCompileExec2369790767.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2369790767.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2369790767.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2369790767
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2369790767.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin    CMakeFiles/cmTryCompileExec2369790767.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2369790767 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1669804475/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1669804475.dir/build.make CMakeFiles/cmTryCompileExec1669804475.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1669804475.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec1669804475.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1669804475
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1669804475.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin    CMakeFiles/cmTryCompileExec1669804475.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1669804475 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4142644240/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4142644240.dir/build.make CMakeFiles/cmTryCompileExec4142644240.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4142644240.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec4142644240.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4142644240
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4142644240.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin    CMakeFiles/cmTryCompileExec4142644240.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4142644240 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1105196697/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1105196697.dir/build.make CMakeFiles/cmTryCompileExec1105196697.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1105196697.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec1105196697.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1105196697
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1105196697.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin    CMakeFiles/cmTryCompileExec1105196697.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1105196697 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3123399553/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3123399553.dir/build.make CMakeFiles/cmTryCompileExec3123399553.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3123399553.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec3123399553.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3123399553
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3123399553.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin    CMakeFiles/cmTryCompileExec3123399553.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3123399553 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec878869207/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec878869207.dir/build.make CMakeFiles/cmTryCompileExec878869207.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec878869207.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec878869207.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec878869207
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec878869207.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin    CMakeFiles/cmTryCompileExec878869207.dir/CheckFunctionExists.c.o  -o cmTryCompileExec878869207 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2181410124/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2181410124.dir/build.make CMakeFiles/cmTryCompileExec2181410124.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2181410124.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec2181410124.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2181410124
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2181410124.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec2181410124.dir/src.c.o  -o cmTryCompileExec2181410124 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2516856867/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2516856867.dir/build.make CMakeFiles/cmTryCompileExec2516856867.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2516856867.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec2516856867.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2516856867
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2516856867.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec2516856867.dir/src.c.o  -o cmTryCompileExec2516856867 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3911271787/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3911271787.dir/build.make CMakeFiles/cmTryCompileExec3911271787.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3911271787.dir/src.c.o
/usr/bin/gcc   -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec3911271787.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3911271787
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3911271787.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec3911271787.dir/src.c.o  -o cmTryCompileExec3911271787 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3843468582/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3843468582.dir/build.make CMakeFiles/cmTryCompileExec3843468582.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3843468582.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3843468582.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3843468582
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3843468582.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3843468582.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3843468582 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1042574859/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1042574859.dir/build.make CMakeFiles/cmTryCompileExec1042574859.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1042574859.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1042574859.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1042574859
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1042574859.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1042574859.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1042574859 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4003590359/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4003590359.dir/build.make CMakeFiles/cmTryCompileExec4003590359.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4003590359.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4003590359.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4003590359
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4003590359.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4003590359.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4003590359 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec966566667/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec966566667.dir/build.make CMakeFiles/cmTryCompileExec966566667.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec966566667.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec966566667.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec966566667
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec966566667.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec966566667.dir/CheckSymbolExists.c.o  -o cmTryCompileExec966566667 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3831611990/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3831611990.dir/build.make CMakeFiles/cmTryCompileExec3831611990.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3831611990.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3831611990.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3831611990
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3831611990.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3831611990.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3831611990 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec632041712/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec632041712.dir/build.make CMakeFiles/cmTryCompileExec632041712.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec632041712.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec632041712.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec632041712
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec632041712.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec632041712.dir/CheckSymbolExists.c.o  -o cmTryCompileExec632041712 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec117877474/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec117877474.dir/build.make CMakeFiles/cmTryCompileExec117877474.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec117877474.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec117877474.dir/CheckSymbolExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec117877474
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec117877474.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec117877474.dir/CheckSymbolExists.c.o  -o cmTryCompileExec117877474 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

File /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2441909261/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2441909261.dir/build.make CMakeFiles/cmTryCompileExec2441909261.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2441909261.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec2441909261.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2441909261
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2441909261.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec2441909261.dir/src.c.o  -o cmTryCompileExec2441909261 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1209007077/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1209007077.dir/build.make CMakeFiles/cmTryCompileExec1209007077.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1209007077.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec1209007077.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1209007077
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1209007077.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec1209007077.dir/src.c.o  -o cmTryCompileExec1209007077 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3344327046/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3344327046.dir/build.make CMakeFiles/cmTryCompileExec3344327046.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3344327046.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec3344327046.dir/src.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3344327046
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3344327046.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec3344327046.dir/src.c.o  -o cmTryCompileExec3344327046 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3057617745/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3057617745.dir/build.make CMakeFiles/cmTryCompileExec3057617745.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3057617745.dir/SIZE_OF_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3057617745.dir/SIZE_OF_SHORT.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec3057617745
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3057617745.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3057617745.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec3057617745 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2511157488/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2511157488.dir/build.make CMakeFiles/cmTryCompileExec2511157488.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2511157488.dir/SIZE_OF_INT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2511157488.dir/SIZE_OF_INT.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec2511157488
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2511157488.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2511157488.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec2511157488 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2255537281/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2255537281.dir/build.make CMakeFiles/cmTryCompileExec2255537281.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2255537281.dir/SIZE_OF_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2255537281.dir/SIZE_OF_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec2255537281
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2255537281.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2255537281.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec2255537281 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1898500586/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1898500586.dir/build.make CMakeFiles/cmTryCompileExec1898500586.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1898500586.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1898500586.dir/SIZE_OF_LONG_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec1898500586
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1898500586.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1898500586.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec1898500586 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2115055385/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2115055385.dir/build.make CMakeFiles/cmTryCompileExec2115055385.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2115055385.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2115055385.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2115055385
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2115055385.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2115055385.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2115055385 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2351850396/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2351850396.dir/build.make CMakeFiles/cmTryCompileExec2351850396.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2351850396.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2351850396.dir/SIZE_OF_UNSIGNED.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec2351850396
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2351850396.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2351850396.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec2351850396 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec151278546/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec151278546.dir/build.make CMakeFiles/cmTryCompileExec151278546.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec151278546.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec151278546.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec151278546
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec151278546.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec151278546.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec151278546 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2032555239/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2032555239.dir/build.make CMakeFiles/cmTryCompileExec2032555239.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2032555239.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2032555239.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec2032555239
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2032555239.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2032555239.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec2032555239 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec409199926/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec409199926.dir/build.make CMakeFiles/cmTryCompileExec409199926.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec409199926.dir/INT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec409199926.dir/INT16_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec409199926
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec409199926.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec409199926.dir/INT16_T.c.o  -o cmTryCompileExec409199926 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1325578354/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1325578354.dir/build.make CMakeFiles/cmTryCompileExec1325578354.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1325578354.dir/INT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1325578354.dir/INT32_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec1325578354
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1325578354.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1325578354.dir/INT32_T.c.o  -o cmTryCompileExec1325578354 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1577814880/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1577814880.dir/build.make CMakeFiles/cmTryCompileExec1577814880.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1577814880.dir/INT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1577814880.dir/INT64_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec1577814880
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1577814880.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1577814880.dir/INT64_T.c.o  -o cmTryCompileExec1577814880 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1317703417/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1317703417.dir/build.make CMakeFiles/cmTryCompileExec1317703417.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1317703417.dir/INTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1317703417.dir/INTMAX_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec1317703417
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1317703417.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1317703417.dir/INTMAX_T.c.o  -o cmTryCompileExec1317703417 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1467381878/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1467381878.dir/build.make CMakeFiles/cmTryCompileExec1467381878.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1467381878.dir/UINT8_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1467381878.dir/UINT8_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec1467381878
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1467381878.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1467381878.dir/UINT8_T.c.o  -o cmTryCompileExec1467381878 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3491910403/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3491910403.dir/build.make CMakeFiles/cmTryCompileExec3491910403.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3491910403.dir/UINT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3491910403.dir/UINT16_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec3491910403
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3491910403.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3491910403.dir/UINT16_T.c.o  -o cmTryCompileExec3491910403 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2224712378/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2224712378.dir/build.make CMakeFiles/cmTryCompileExec2224712378.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2224712378.dir/UINT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2224712378.dir/UINT32_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec2224712378
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2224712378.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2224712378.dir/UINT32_T.c.o  -o cmTryCompileExec2224712378 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3657564957/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3657564957.dir/build.make CMakeFiles/cmTryCompileExec3657564957.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3657564957.dir/UINT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3657564957.dir/UINT64_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec3657564957
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3657564957.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3657564957.dir/UINT64_T.c.o  -o cmTryCompileExec3657564957 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec499161549/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec499161549.dir/build.make CMakeFiles/cmTryCompileExec499161549.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec499161549.dir/UINTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec499161549.dir/UINTMAX_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec499161549
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec499161549.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec499161549.dir/UINTMAX_T.c.o  -o cmTryCompileExec499161549 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2037739572/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2037739572.dir/build.make CMakeFiles/cmTryCompileExec2037739572.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2037739572.dir/DEV_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2037739572.dir/DEV_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec2037739572
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2037739572.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2037739572.dir/DEV_T.c.o  -o cmTryCompileExec2037739572 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec323679012/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec323679012.dir/build.make CMakeFiles/cmTryCompileExec323679012.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec323679012.dir/GID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec323679012.dir/GID_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec323679012
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec323679012.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec323679012.dir/GID_T.c.o  -o cmTryCompileExec323679012 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec921755454/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec921755454.dir/build.make CMakeFiles/cmTryCompileExec921755454.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec921755454.dir/ID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec921755454.dir/ID_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec921755454
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec921755454.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec921755454.dir/ID_T.c.o  -o cmTryCompileExec921755454 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1409525677/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1409525677.dir/build.make CMakeFiles/cmTryCompileExec1409525677.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1409525677.dir/MODE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1409525677.dir/MODE_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec1409525677
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1409525677.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1409525677.dir/MODE_T.c.o  -o cmTryCompileExec1409525677 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1665337283/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1665337283.dir/build.make CMakeFiles/cmTryCompileExec1665337283.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1665337283.dir/OFF_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1665337283.dir/OFF_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec1665337283
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1665337283.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1665337283.dir/OFF_T.c.o  -o cmTryCompileExec1665337283 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3316908552/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3316908552.dir/build.make CMakeFiles/cmTryCompileExec3316908552.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3316908552.dir/SIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3316908552.dir/SIZE_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec3316908552
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3316908552.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3316908552.dir/SIZE_T.c.o  -o cmTryCompileExec3316908552 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3524264427/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3524264427.dir/build.make CMakeFiles/cmTryCompileExec3524264427.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3524264427.dir/SSIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3524264427.dir/SSIZE_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec3524264427
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3524264427.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3524264427.dir/SSIZE_T.c.o  -o cmTryCompileExec3524264427 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2158757817/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2158757817.dir/build.make CMakeFiles/cmTryCompileExec2158757817.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2158757817.dir/UID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2158757817.dir/UID_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec2158757817
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2158757817.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2158757817.dir/UID_T.c.o  -o cmTryCompileExec2158757817 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3886712599/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3886712599.dir/build.make CMakeFiles/cmTryCompileExec3886712599.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3886712599.dir/PID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3886712599.dir/PID_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec3886712599
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3886712599.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3886712599.dir/PID_T.c.o  -o cmTryCompileExec3886712599 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec132141394/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec132141394.dir/build.make CMakeFiles/cmTryCompileExec132141394.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec132141394.dir/INTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec132141394.dir/INTPTR_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec132141394
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec132141394.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec132141394.dir/INTPTR_T.c.o  -o cmTryCompileExec132141394 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2492678994/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2492678994.dir/build.make CMakeFiles/cmTryCompileExec2492678994.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2492678994.dir/UINTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2492678994.dir/UINTPTR_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec2492678994
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2492678994.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2492678994.dir/UINTPTR_T.c.o  -o cmTryCompileExec2492678994 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1826901363/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1826901363.dir/build.make CMakeFiles/cmTryCompileExec1826901363.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1826901363.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1826901363.dir/SIZEOF_WCHAR_T.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec1826901363
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1826901363.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1826901363.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec1826901363 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2757529854/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2757529854.dir/build.make CMakeFiles/cmTryCompileExec2757529854.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2757529854.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2757529854.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2757529854.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2757529854/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec613015168/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec613015168.dir/build.make CMakeFiles/cmTryCompileExec613015168.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec613015168.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec613015168.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: fatal error: rmd160.h: No such file or directory
 #include <rmd160.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec613015168.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec613015168/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2076018096/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2076018096.dir/build.make CMakeFiles/cmTryCompileExec2076018096.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2076018096.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2076018096.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: fatal error: sha1.h: No such file or directory
 #include <sha1.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2076018096.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2076018096/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec642707242/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec642707242.dir/build.make CMakeFiles/cmTryCompileExec642707242.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec642707242.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec642707242.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec642707242.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec642707242/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4215089471/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4215089471.dir/build.make CMakeFiles/cmTryCompileExec4215089471.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4215089471.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4215089471.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec4215089471.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec4215089471/fast] Error 2
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec803992557/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec803992557.dir/build.make CMakeFiles/cmTryCompileExec803992557.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec803992557.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec803992557.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec803992557.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec803992557/fast] Error 2
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1824063017/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1824063017.dir/build.make CMakeFiles/cmTryCompileExec1824063017.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1824063017.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1824063017.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1824063017.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec1824063017/fast] Error 2
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3419316181/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3419316181.dir/build.make CMakeFiles/cmTryCompileExec3419316181.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3419316181.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3419316181.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3419316181.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3419316181/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1056708119/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1056708119.dir/build.make CMakeFiles/cmTryCompileExec1056708119.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1056708119.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1056708119.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1056708119.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1056708119/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1485560362/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1485560362.dir/build.make CMakeFiles/cmTryCompileExec1485560362.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1485560362.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1485560362.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1485560362.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1485560362/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec871689706/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec871689706.dir/build.make CMakeFiles/cmTryCompileExec871689706.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec871689706.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec871689706.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec871689706.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec871689706/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1626382332/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1626382332.dir/build.make CMakeFiles/cmTryCompileExec1626382332.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1626382332.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1626382332.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1626382332.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1626382332/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2815678515/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2815678515.dir/build.make CMakeFiles/cmTryCompileExec2815678515.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2815678515.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2815678515.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2815678515.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2815678515/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2399656857/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2399656857.dir/build.make CMakeFiles/cmTryCompileExec2399656857.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2399656857.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2399656857.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2399656857.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2399656857/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4198173326/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4198173326.dir/build.make CMakeFiles/cmTryCompileExec4198173326.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4198173326.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4198173326.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec4198173326.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec4198173326/fast] Error 2
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1806657052/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1806657052.dir/build.make CMakeFiles/cmTryCompileExec1806657052.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1806657052.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1806657052.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1806657052.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1806657052/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1532907099/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1532907099.dir/build.make CMakeFiles/cmTryCompileExec1532907099.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1532907099.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1532907099.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1532907099.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1532907099/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4238663815/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4238663815.dir/build.make CMakeFiles/cmTryCompileExec4238663815.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4238663815.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4238663815.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec4238663815.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec4238663815/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4212013417/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4212013417.dir/build.make CMakeFiles/cmTryCompileExec4212013417.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4212013417.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4212013417.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: fatal error: ripemd.h: No such file or directory
 #include <ripemd.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec4212013417.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec4212013417/fast] Error 2
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2427271310/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2427271310.dir/build.make CMakeFiles/cmTryCompileExec2427271310.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2427271310.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2427271310.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: fatal error: sha.h: No such file or directory
 #include <sha.h>
                 ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2427271310.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2427271310/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec663629230/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec663629230.dir/build.make CMakeFiles/cmTryCompileExec663629230.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec663629230.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec663629230.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: fatal error: sha256.h: No such file or directory
 #include <sha256.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec663629230.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec663629230/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3424604788/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3424604788.dir/build.make CMakeFiles/cmTryCompileExec3424604788.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3424604788.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive -I/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3424604788.dir/check_crypto_md.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: fatal error: sha512.h: No such file or directory
 #include <sha512.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3424604788.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3424604788/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3076566777/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3076566777.dir/build.make CMakeFiles/cmTryCompileExec3076566777.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3076566777.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3076566777.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec3076566777
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3076566777.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3076566777.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec3076566777 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/x86_64-linux-gnu/libcurses.so passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2559741475/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2559741475.dir/build.make CMakeFiles/cmTryCompileExec2559741475.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2559741475.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec2559741475.dir/CheckFunctionExists.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2559741475
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2559741475.dir/link.txt --verbose=1
/usr/bin/gcc     -DCHECK_FUNCTION_EXISTS=wsyncup    CMakeFiles/cmTryCompileExec2559741475.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2559741475 -rdynamic -lcurses 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3207749322/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3207749322.dir/build.make CMakeFiles/cmTryCompileExec3207749322.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3207749322.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3207749322.dir/CheckIncludeFile.c.o   -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3207749322
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3207749322.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3207749322.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3207749322 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'


Performing C++ SOURCE FILE Test run_pic_test succeded with the following output:
Change Dir: /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4201209582/fast"
make[4]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4201209582.dir/build.make CMakeFiles/cmTryCompileExec4201209582.dir/build
make[5]: Entering directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4201209582.dir/src.cxx.o
/usr/bin/g++    -Drun_pic_test   -fPIE -o CMakeFiles/cmTryCompileExec4201209582.dir/src.cxx.o -c /home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp/src.cxx
Linking CXX executable cmTryCompileExec4201209582
/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4201209582.dir/link.txt --verbose=1
/usr/bin/g++      -Drun_pic_test    CMakeFiles/cmTryCompileExec4201209582.dir/src.cxx.o  -o cmTryCompileExec4201209582 -rdynamic 
make[5]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/dogi/openwrt/trunk/build_dir/host/cmake-2.8.11.2/CMakeFiles/CMakeTmp'

Source file was:
int main() { return 0;}
